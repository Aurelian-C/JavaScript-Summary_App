# Object Prototypes

Prototypes are the mechanism by which JavaScript **objects inherit features from one another**.

## The prototype chain

In the browser's console, try creating an object literal:

```js
const myObject = {
  city: 'Madrid',
  greet() {
    console.log(`Greetings from ${this.city}`);
  },
};

myObject.greet(); // Greetings from Madrid
```

This is an object with _one data property_, `city`, and _one method_, `greet()`. If you type the object's name _followed by a period_ into the console, like `myObject.`, then the console will pop up a list of all the properties available to `myObject` object. You'll see that besides `city` and `greet`, there are lots of other properties!

```
__defineGetter__
__defineSetter__
__lookupGetter__
__lookupSetter__
__proto__
city
constructor
greet
hasOwnProperty
isPrototypeOf
propertyIsEnumerable
toLocaleString
toString
toValueOf
```

If you access a one of them `myObject.toString(); // "[object Object]"` it works. What are these extra properties, and where do they come from?

Every object in JavaScript has a **built-in property**, which is called its `prototype`. The `prototype` **is itself an object**, so the `prototype` will have its own `prototype`, making what's called a **prototype chain**. The chain ends when we reach a prototype that has `null` for its own prototype. _**The property of an object that points to its prototype is not called `prototype`. Its name is not standard, but in practice all browsers use `__proto__`**_. The standard way to access an object's prototype is the `Object.getPrototypeOf()` method.

```js
// __proto__ property
myObject.__proto__; // {constructor: f}

// Object.getPrototypeOf()
Object.getPrototypeOf(myObject); // {constructor: f}
```

When you try to access a property of an object, if the property can't be found in the object itself, the prototype is searched for the property. If the property still can't be found, then the prototype's prototype is searched, and so on until either the property is found, or the end of the chain is reached, in which case `undefined` is returned.

So when we call `myObject.toString()`, the browser:

- looks for `toString` in `myObject`
- can't find it there, so looks in the prototype object of `myObject` for `toString`
- finds it there, and calls it.

This is an object called `Object.prototype`, and it is the most basic prototype, that all objects have by default. The prototype of `Object.prototype` is `null`, so it's at the end of the prototype chain:

![prototype-chain](../../img/oop_prototype-chain.jpg)

The prototype of an object is not always `Object.prototype`:

```js
const myDate = new Date();
let object = myDate;

do {
  object = Object.getPrototypeOf(object);
  console.log(object);
} while (object);

// Date.prototype
// Object {...}
// null
```

This code creates a `Date` object, then walks up the prototype chain, logging the prototypes. It shows us that the prototype of `myDate` is a `Date.prototype` object, and the prototype of that is `Object.prototype`.

![prototype-chain1](../../img/oop_prototype-chain1.jpg)

In fact, when you call familiar methods, like `myDate2.getMonth()`, you are calling a method that's defined on `Date.prototype`.

## Shadowing properties

What happens if you define a property in an object, when a property with the same name is defined in the object's prototype?

```js
const myDate = new Date(1995, 11, 17);

console.log(myDate.getYear()); // 95

myDate.getYear = function () {
  console.log('something else!');
};

console.log(myDate.getYear()); // 'something else!'
```

This should be predictable, given the description of the prototype chain. When we call `getYear()` the browser first looks in `myDate` for a property with that name, and **only checks the prototype if `myDate` does not define it**. So when we add `getYear()` to `myDate`, then the version in `myDate` is called.

This is called **"shadowing" the property**.

## Setting a prototype

How do we actually create prototypes? And how do we link objects to prototypes? There are various ways of setting an object's prototype in JavaScript.

1. `Object.create()`

   - The easiest and most straightforward way of _**linking an object to a prototype object**_.

2. Constructor functions

   - Technique to _**create objects from a function**_;
   - This is how built-in objects like Arrays, Maps or Sets are actually implemented.

3. ES6 Classes
   - Modern _**alternative to constructor function syntax**_;
   - "_**Syntactic sugar**_": behind the scenes, ES6 classes work exactly like constructor functions;
   - ES6 classes do NOT behave like classes in "classical OOP" like Java or C++.

## Prototypes and inheritance

Prototypes are a powerful and very flexible feature of JavaScript, making it possible to **reuse code** and **combine objects**.

In particular they support a version of **inheritance**. **_Inheritance is a feature of Object-Oriented Programming languages that lets programmers express the idea that some objects in a system are more specialized versions of other objects_**.

For example, if we're modeling a school, we might have _professors_ and _students_: they are both _people_, so have some features in common (for example, they both have names), but each might add extra features (for example, _professors_ have a subject that they teach), or might implement the same feature in different ways. In an OOP system we might say that professors and students both **inherit from** _people_.

You can see how in JavaScript, if `Professor` and `Student` objects can have `Person` prototypes, then they can inherit the common properties, while adding and redefining those properties which need to differ.

## Prototypal Inheritance on Built-In Objects

Prototypal Inheritance is a **mechanism for reusing code**. So all of built-in array methods have to exist only once somewhere in the JavaScript engine and then all the arrays in our code get access to the functions through the prototype chain and prototypal inheritance.

```js
const arr = [1, 2, 3, 4, 5, 7, 2, 3]; // [] = new Array()

arr.__proto__ === Array.prototype; //true; So one more time, the prototype property of the constructor is gonna be the prototype of all the objects created by that constructor.

arr.__proto__.__proto__; //Object.prototype
```

**Extending the prototype of a built-in object is generally not a good idea**.

- The first reason is that the next version of Javascript might add a method with the same name that we are adding, but it might work in a different way and so your code will then use that new method which, remember, works differently and then that will probably break your code.
- The second reason why you shouldn't do this is because when you work on a team of developers, then this is really gonna be a bad idea because if multiple developers implement the same method with a different name, then that's just going to create so many bugs that it's just not worth doing this.

```js
Array.prototype.unique = function () {
  // we added a new method to the prototype property of the array constructor. And so therefore now all arrays will inherit this method.
  return [...new Set(this)];
};
```

```js
console.dir(x => x + 1); // THE FUNCTION ITSELF IS ALSO AN OBJECT and this is the reason why we can actually call methods like bind() on functions. It's because they are objects and objects have prototypes.
```

References

1. [Object prototypes - MDN](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes)

2. [The Complete JavaScript Course. From Zero to Expert! - Jonas Schmedtmann](https://www.udemy.com/course/the-complete-javascript-course/?utm_source=adwords&utm_medium=udemyads&utm_campaign=JavaScript_v.PROF_la.EN_cc.ROWMTA-B_ti.6368&utm_content=deal4584&utm_term=_._ag_130756014153_._ad_558386196906_._kw__._de_c_._dm__._pl__._ti_dsa-774930039569_._li_1011789_._pd__._&matchtype=&gclid=CjwKCAjwiuuRBhBvEiwAFXKaNCuaAhZ8UB5kIldtb76eeAyfM0SUKeceBq3FKF24pNxDVe-_g0-DPxoCnWwQAvD_BwE)
